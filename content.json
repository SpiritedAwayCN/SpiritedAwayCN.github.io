{"pages":[],"posts":[{"title":"【置顶】AstroMC进度概览","text":"当前工程：下界交通-二环路/潜影贝农场(1.17)/守卫者农场(1.17)/虚空交易大厅(1.17) 西二环全线、南要塞引道、北二环西路：完工北二环东路、东二环北路：规划中东二环南路：冰道待拓宽，内饰待装修南二环西路、南二环东路：全线冰道完工，内饰待装修 About AstroMC AstroMC 是由我本人与好友@IcyChlorine于2019年11月1日在个人主机上开启的Minecraft原版生存服务器，当时版本为1.14.4。本服务器被定性为好友间的小型生电服务器，随着时间的推移，服务器内的资源愈加充分，但我们从未停止前进与超越的脚步……目前，AstroMC的版本是1.16.4，并于2020年11月5日起托管于@AliceSpace的私人服务器上。 服务器成员 Spirited_Away_ IcyChlorine architect_cs 服务器相关配置地址：mcsm.alicespace.cn:25568版本：1.16.4模式：生存（非成员玩家为旁观） 特殊： 开启仙人掌翻转、经验球合并优化 无人在线时日夜交替关闭，有人时开启 旁观模式不能加载区块 除TNT复制与破基岩外，不利用耗费精力与收获严重不对等的暴利BUG（包括0t、刷沙机、物品复制等） 服务器现存工程/建筑下界交通地图 主世界——主基地周边 名称 效率/规格 备注 main storage - 主存储大厅，物品核心存储处，常用物品有自动分类 小铁厂 500铁锭/h 来源：ilmango 小白桦树场 ~2k原木/h 消耗骨粉，来源：ilmango 村民交易大厅 12街*16格 产出绿宝石、附魔书、陶瓦、钻石盔甲与工具等 主世界刷怪塔 1.7w物品/h 来源：ilmango 竹农场/熔炉组 手动开关 现只用于收割竹子，熔炉组已由均衡熔炉阵列代替 史莱姆农场 ~1k粘液球/h 自动接入main storage存储 均衡熔炉阵列 46熔炉阵列 来源：ilmango 甘蔗南瓜西瓜机 小而慢 自动接入main storage存储 洗牛机 皮革 牛排 弃用，现已由疣猪兽农场代替 小木屋 未入住，甚至被雷劈掉了屋顶的一个方块 农田/牛羊猪圈 农田包括胡萝卜 土豆 甜菜 小麦 紫颂花 甘蔗 仙人掌 主世界——主基地外 名称 位置 效率/规格 备注 主世界伪和平 (725, -2727) 281只凋灵 供4人伪和平 竖式刷石机 ~(-345, -380) 1.3w圆石/h 来源：黑山大叔 橡木/云杉树场 ~(-345, -380) 比白桦快 消耗骨粉 小型刷冰机 ~(-345, -380) - 弃用，现已由大型刷冰机替代 棕蘑菇机 ~(-345, -380) 未测试 消耗骨粉 女巫塔 ~(-356, -299) 4k物品/h 弃用，已由新raid farm替代 raid farm ~(275, 947) 3k绿宝石/h 弃用，已由新raid farm替代 珊瑚扇机 ~(476, -1008) 未测试 消耗骨粉。来源：黑山大叔 大型刷冰机 ~(-4570, -1816) 3k+冰/13min 需要钻石镐，来源：黑山大叔 raid farm* (1010, -1040) 5.2w绿宝石,4k+红石/h 修改自：黑山大叔 刷花机*[规划中]* ~(-1500, -500) 守卫者农场*[建设中]* ~(-2440, -1720) 已排完水 下界下界工程位置，如无特殊说明，位置均以下界交通地图为准。 名称 效率/规格 备注 下界猪人塔 未测试，但效率可观 修改自ilmango，产出金、经验 烈焰人农场 250烈焰棒/h 修改自Rays works，基于刷怪笼 凋灵骷髅农场 12.5头/min, 5.8w物品/h 煤炭、骨头主要来源 全速杀凋机 4500头/h 需要凋灵骷髅头颅、灵魂沙/灵魂土 疣猪兽农场 1k皮革, 1w熟猪排/h 恶魂农场 未测试 修改自黑山大叔，双维度 下界伪和平*[规划中]* 末地 名称 位置 效率/规格 备注 凋零玫瑰农场 ~(-300, 0) 6.7k玫瑰,3.6h末影珍珠/h 抗卸载，但不抗重启！ 村民交易大厅*[规划中]* 将代替主世界村民交易大厅","link":"/2020/11/18/AstroServer-top/"},{"title":"基于直线交点的少量末影之眼计算要塞坐标方案","text":"说明：本文内容层于2018年6月发布于MCBBS，并被设为推荐，但因为时间久远而不再可见，因此全文挪到博客中了。 毕竟刚高考完就写的，也不是什么高级方法，看看就好。 使用地址：网页使用，C++源码见本文 一、前言Minecraft中生存模式且非作弊的条件下，主世界要塞是通往末地并击杀末影龙的唯一途径，且其内部有丰富的宝藏。这意味着要塞在Minecraft玩家梦寐以求之地。而Minecraft的道具末影之眼会为我们指向最近的要塞方向，这位我们寻找要塞提供了极大的便利。但是每次抛出的末影之眼都有1/6概率遭到破坏。而事实上，寻找要塞的只需两个末影之眼表明方向即可。当然，多抛几次有利于减小误差。这类教程可能之前已经有坛友发过，而这次会将这个方法讲得更细致，这里将简要地探讨利用两次（或更多）末影之眼方向的数据来直接定位要塞坐标的方法。 二、基本原理1. 坐标在数字上反映了玩家在主世界中的位置。坐标基于一个由三条交于一点（即原点）的坐标轴而形成的网格。玩家会出生在距离原点数百方块的位置上。x轴反映了玩家距离原点在东（+）西（-）方向上的距离；z轴反映了玩家距离原点在南（+）北（-）方向上的距离。（粘贴自wiki，CC BY-NC-SA 3.0）。 2.调试屏幕F3键呼出，显示区块缓存、内存使用、各种参数、玩家的当前坐标和当前游戏帧率图表（粘贴自wiki）。在“两点”法寻找要塞的过程中，我们需要关注调试屏幕中的三个数据：X坐标①Z坐标②与当前朝向（Facing）中的一个参数③。如下图所示： 3.平面上两条非平行线交于一点这是一个很直观的结论，事实上这是平行线定义的逆否命题。 三、理论计算（两次末影之眼）在Minecraft中，x轴的正方向为正东方向，z轴的正方向为正南方向，而第二版块中③所表示的值（-180.0~180.0）表示一个角度，其以z轴正方向为始边，顺时针方向为正方向。基于以上原理，两次末影之眼确定要塞的原理大致如下图所示： 其中，A点与B点为末影之眼的抛出点，它们共同指向要塞S点。我们不难发现，如果这两条直线不平行，那么我们可以确定要塞的准确位置。下面，我们将来推导这一个要塞的坐标公式：（作者2021.04.12注：3年前写的，懒得用latex再打一遍公式了） 于是，S点的坐标得以导出，第二版块中的①，②，③分别对应式中的$x$，$z$，$θ$。 四、一个小验证因为种种原因，验证的图片我实在是找不到了，但可以简单地阐述一下验证步骤与结果： 步骤：1.在某一点抛出末影之眼，准星指向末影之眼悬停处，记录第二版块中的①②③三项数据；2.以与1中方向接近90°的锐角方向行走约120米，再重复步骤1；3.带入第三板块中的计算式，求得要塞坐标；4.tp至理论坐标，以旁观者模式观测地下构造。 结果：发现要塞结构（新版本的末影之眼不再指向末地传送门，而是指向要塞结构）位于距脚下5m左右（水平距离）。（作者2021.04.12注：末影之眼指向要塞的起始楼梯位置） 五、从两个末影之眼到多个末影之眼从第四版块的验证中我们不难发现，我们的算法基本正确，但仍有些许误差。事实上，由于在调试屏幕中表示朝向的角度只保留了1位小数，而要塞的距离一般距离玩家较远使得角度之差较小（一般都只有8°左右），因此导致的误差可能不小。我们可以用多抛几次末影之眼的方法来进行修正。 修正算法：1.在多处不同的地点抛出末影之眼（注意确保这些末影之眼指向同一个要塞），记录对应数据，如记录了n组数据；2.若这n条直线两两相交，则一共有n(n+1)/2个交点；3.求出覆盖这n(n+1)/2个点的最小圆圆心，以此圆心作为要塞的基准点，而此圆的半径可用于衡量误差。 最小覆盖圆算法： 这个博客已经较为清楚的阐明，此处不再赘述（链接链至CSDN博客） 六、C++源代码作者2021.04.12注：这是C++版本的代码，现已有JS版本可直接在网页使用，由@lintx移植。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define MAXN 101using namespace std;struct coordinate{ double x,z;}loc[MAXN],res[MAXN*(MAXN-1)/2],circle;double f[MAXN],radius=0;int n,cnt;const double pai=3.141592653589793;coordinate calc(int i,int j){ coordinate result; result.x=(loc[i].x*cos(f[i])*sin(f[j])-loc[j].x*sin(f[i])*cos(f[j])+(loc[i].z-loc[j].z)*sin(f[i])*sin(f[j]))/sin(f[j]-f[i]); result.z=(loc[j].z*cos(f[i])*sin(f[j])-loc[i].z*sin(f[i])*cos(f[j])-(loc[i].x-loc[j].x)*cos(f[i])*cos(f[j]))/sin(f[j]-f[i]); return result;}double get_distance(coordinate a,coordinate b){ return sqrt(pow(a.x-b.x,2)+pow(a.z-b.z,2));}bool In_Cir(coordinate point){ return get_distance(point,circle)&lt;=radius+0.001;}coordinate solve(double A1,double B1,double C1,double A2,double B2,double C2){ if(A1*B2-A2*B1==0) return circle; return (coordinate){(C1*B2-C2*B1)/(A1*B2-A2*B1),(A1*C2-A2*C1)/(A1*B2-A2*B1)};}void get_MinCir(){ double temp; for(int i=1;i&lt;=cnt;i++) if(!In_Cir(res[i])){ circle.x=res[i].x,circle.z=res[i].z,radius=0; for(int j=1;j&lt;i;j++) if(!In_Cir(res[j])){ circle.x=(res[i].x+res[j].x)/2.0,circle.z=(res[i].z+res[j].z)/2,radius=get_distance(res[i],circle); for(int k=1;k&lt;j;k++) if(!In_Cir(res[k])){ circle=solve(2*(res[j].x-res[i].x),2*(res[j].z-res[i].z),pow(res[j].x,2)+pow(res[j].z,2)-pow(res[i].x,2)-pow(res[i].z,2), 2*(res[k].x-res[j].x),2*(res[k].z-res[j].z),pow(res[k].x,2)+pow(res[k].z,2)-pow(res[j].x,2)-pow(res[j].z,2)); radius=get_distance(circle,res[k]); } } } }int main(){ //freopen(&quot;stronghold.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lf%lf%lf&quot;,&amp;loc[i].x,&amp;loc[i].z,&amp;f[i]); f[i]*=pai/180.0; } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;i;j++){ if(f[i]==f[j]) continue; res[++cnt]=calc(i,j); } for(int i=1;i&lt;=cnt;i++) printf(&quot;x=%.3lf,z=%.3lf\\n&quot;,res[i].x,res[i].z); random_shuffle(res+1,res+cnt+1); get_MinCir(); printf(&quot;\\nThe final result is:\\n&quot;); printf(&quot;x=%.3lf,z=%.3lf\\nr=%.3lf\\n&quot;,circle.x,circle.z,radius); system(&quot;pause&quot;);} 七、基于程序的操作验证（图文）首先，我抛出了4个末影之眼，记录的数据分别如下： 接下来，把这4个数据输入我们的程序（为方便起见，这里已经改为使用文件输入，输入的顺序可能与图片顺序略有不同），输出结果如下： 输出结果中，前6行表示这四条直线两两相交所形成的6个交点的坐标，最后的x,z,r代表着这6个点最小覆盖圆的坐标以及半径。从输出结果来看，最小覆盖圆的半径只有约10m，当然在我们所理想的误差范围内，下面我们tp至目标点（也就是最小覆盖圆的圆心，x=-494,z=817）进行验证，发现正下方即是要塞，如下图： 八、误差分析以下操作可能导致严重的误差，请务必避免： 抛出的末影之眼中可能存在两个或更多指向不同要塞。这在程序中的表现为最小覆盖圆的半径可能很大，保证不同末影之眼的抛出点相距不太远即可； 抛出的末影之眼中可能存在两个或更多指向角度相同或极其接近。解决方法见下文的第一点。 以下操作有助于减小误差，由于角度数据中，调试屏幕只保留了一位小数，而最大的误差往往来自于角度之差，因此要使角度之差尽量的大： 抛出一个末影之眼后，与其方向呈接近90度的一个锐角前进，在前进相同距离的情况下大体上可保证角度最大； 前进的距离可大致控制在80~180格，太小可能使角度差值不大，太大可能导致末影之眼指向不同的要塞； 多抛几个末影之眼，建议抛（不同位置）3~4个，由此定位的误差相对较小。 到达理论点后： 因为这只是一个大致位置，要塞可能在该点附近而不在该点上。因此可以向下挖后再向旁边挖挖，或再重复一次前文操作。 九、补充这是基于点角式直线的计算，我也写过一个两点式的，实测误差更大，有空再填坑。","link":"/2021/04/12/StrongholdCalc/"},{"title":"2020-2021秋季学期总结","text":"本学期，我选修了以下几门课程：理论计算机科学基础、图像处理、信号与系统、操作系统(B)（含实习）、脑与认知科学、围棋（初级班）、西方音乐欣赏、马克思主义原理概论。并担任一门课程的助教：计算机系统导论。 总的来说，这学期非常忙碌，尤其是期末季，甚至出现了操作系统没有复习完就上考场的情况。 以下测评大致按本学期的收获与体验感排序： 理论计算机科学基础本学期最虐，同时也是收获最大的课。首先介绍语言与自动机，包括有穷自动机、下推自动机、确定性下推自动机，对应正则语言、上下文无关语言；然后介绍图灵机可计算理论，以及递归定理；最后介绍复杂性理论。 第一部分语言与自动机，解决了上学期学PL概论课程的时候对于正则表达式和上下文无关文法的疑问；第二部分可计算理论，研究了一堆不可计算问题，存在任意塔的增长，感受到不可计算问题其实也有明确而严格的难度之分，以及奇妙的递归定理——一个图灵机可以在内部获得自己的描述，换言之一个程序可以获取自己的代码。最后复杂性理论，闲话少说，直接上图： 图像处理经典的图像处理算法，基本没有涉及深度学习相关的，但这真的已经非常强大了，参见我春季学期破解选课网验证码的repo，如果没有这门课所学知识我是做不出如此好的效果的。先前算法设计与分析小班选读论文就是cv相关，这个学期更加深入了解了图像处理有关算法，有趣而实用，对CV感兴趣或者有好奇的同学不要错过这门课~ 缺点就是，出分有点慢（快开学才出），以及期末大作业火车票二维码识别，导致现在看到二维码有点PTSD（大雾） 围棋（初级班）围棋零基础，纯好奇选了这个。感觉瞬间打开了新世界的大门，虽然现在水平依然个菜鸟（估计10K左右），但是这门课（或许）培养了一个终身的小爱好？而且方天丰老师讲课生动有趣，并且偏棋理（毕竟围棋博大精深但学时太少），所以对围棋思想有了非常深刻的认识。现在没事就喜欢下着玩，有生之年能不能达到个业余一段呢（雾） 信号与系统工科数学课，数理上不太严谨（看起来头大），不过算是搞明白了傅里叶变换拉普拉斯变换Z变换，时域和频域能互相变换真的太美妙同时又太有应用价值了（比如图像处理）！ 西方音乐欣赏很遗憾，因为西音完了就是ics小班课，所以这学期西音课上几乎都在备小班课，也没怎么听，不过把部分录播爬了下来留作日后观赏。 操作系统(B)（含实习）感觉很文科，没有操统A的lab最后是看Linux源码的一个part（我们看的内存管理），主要Linux源码太多了，系统也太庞大了，我觉得读读xv6的源代码，但把各个部分都读一读应该会收获更大。期末考试，感觉靠背的题好多不确定，倒是靠推导的题非常有把握（其实就是没复习完……）。 马克思主义原理概论做了个什么都不懂的pre，上课摸鱼，考试乱写，最后分数竟然还行（ 脑与认知科学………………………………………………………… 下一学期展望：继续理论，继续实践，继续MC！","link":"/2021/02/01/2020-2021Autumn-Summary/"},{"title":"Minecraft——我心中的瓦尔登湖","text":"这是一个故事，我与Minecraft的故事，我与我自己的故事…… 初见2014年，暑假。每天和一位初中的好友在小区练习中考体育实心球。 有一天，投累了休息时，他突然说：“我修一会地铁”。作为一名轨道交通的爱好者，我瞬间来了兴趣。只见他手机屏幕上，一条铁轨穿山越岭上天入地，在铁轨旁挖了一个小空间，加了些光源装饰，美其名曰“站台”，一排阶梯直通地表，美其名曰“出入口”…… 2014年7月，我遇见了对我人生态度与人生信念影响最大的游戏——Minecraft！ 当天晚上，我即刻在我性能极差的手机上下载了这款游戏。由于Android系统太老且手机硬件无法支持升级，因此我下载的版本是0.8.0，有限世界类型、没有自然生成的矿洞。而在这卡顿极其严重的手机上，我当天竟然玩到了凌晨2点，也不肯入睡…… 遗憾的是，我现在已无法记得具体的日期，但我仍记得当时携带版的最新版本是Alpha 0.9.X，因此我个人将0.9.4版本的发布日期——2014年7月17日，作为我在Minecraft世界的生日。 萌新突然好奇，创建世界时选择了Survival mode。 界面左上方出现了生命条，所有的材料需要自己挖掘、收集，感觉就像鲁滨逊在孤岛上生存一样…… 用空手花很长的时间挖掉一块石头却发现什么都没有掉落的惊奇；第一次打开合成表的迷惑；在第一个夜晚被各种生物追杀的惶恐；在第二天早晨与苦力怕来了个亲密的拥抱；第一次在矿洞中迷路的彷徨…… 第一次发现合成表奥秘的惊喜；第一次战胜敌对生物的成就感；第一次挖出钻石的激动；…… 这样的感觉，现在已经没有办法复制，但我相信每一位MC玩家，或者曾经的MC玩家都有属于自己的回忆。 朋友初三时，初中同学有很多喜欢玩Minecraft的同学，课间饭后，Minecraft中各种有趣的事情都是我们经常讨论的话题，充满了欢乐。 在同学的帮助下，我在电脑上玩上了MC（的盗版），第一个版本是1.7.9，感觉电脑版的世界地形更加壮观、宏伟。我在里面修了很多地铁，也在里面玩起了生存。 同时，我们筹备了在中考结束后做一次大型的联机，一起在Minecraft中畅玩，为此，我初三下学期研究了Minecraft服务器的配置、管理，以及内网穿透等计算机网络相关的知识。 而也在中考前，我们甚至在一起联机了不少次，有好友间打打杀杀的欢乐，有一起冒险挑战的合作，还有做一些整蛊装置已经被整蛊的好玩感，被下界猪人团灭但依旧快乐而情绪高昂…… 这段时期，是我人生前18年中最快乐的时期。一直持续到了中考结束。 低谷中考结束以后，玩了好久的MC。但是，每当在一个生存存档击败末影龙，回到主世界后，心中却是茫然……我不知道我需要干什么，我更不知道我想干什么。 表面上说要建造一些宏大的建筑，但是一直没有开建，材料不足、过程无聊……一种一个人的孤独感油然而生。因此，每次打完末影龙便新开一个存档，但总觉得少了些色彩。 JAVA版1.9发布，战斗机制被大幅度更改，而我无法适应，因此永远停留在1.8版本。但是，驻留往往意味着没有新生事物，加之本来有许多可以深入探索的游戏内容，我却打完末影龙之后丧失了继续动力。随着高中的到来，我已经很少开启MC了。 虽然我很少玩，但我也一直认为自己依然是MC玩家，MC也一直在电脑里没有被我删掉。 一直狗狗蹲在家门口，望着夕阳西下，苦力怕问到：“你的主人呢？矿洞遇难了？”，狗摇摇头。“去末地一去不返了？”，狗摇摇头。“在大海上迷路了？”，狗摇摇头：“不，他只是长大了。” 2017年8月，我用奖学金购买了Minecraft正版。尽管正版与盗版没有太多实质上的区别，但我认为，这笔钱在MC曾经给我带来的快乐面前，不值一提。是值得的。 转折高三，四月。 复习得无聊，我突然心血来潮，开启了一个全新的Minecraft最新版本存档，版本是1.12.2，1.8时代引退而刚入此版本，刚开始有些许的不适应。 也许是高三最后实在是太无聊了，也或许是太长时间没玩了，突然又来了些兴趣，不过这次我没有急着去打末影龙，因为毕竟高三，偷偷玩电脑不容易，就不干一些情绪高亢的环节了。 我就像陶渊明一样，在自己的小房间周围整了一片地，时而在自己的农田中耕作，时而面对夕阳垂钓，在繁忙而枯燥的高三后期，我感到了无比的惬意。 同一时间，我看到了籽岷的极限生存系列。可以说，这个视频系列完全颠覆了我对Minecraft这款游戏的理解。籽岷在一条河畔，建立起了小家，将那条河命名为“塞纳河”，配着轻松的音乐，自给自足，时而到附近的山上登高揽胜，时而下矿洞收集资源，而后有回来装点着自己的周围…… 我终于明白：末影龙，只是一个目标，但这并不是这个游戏结束的标志。MC给予玩家的，是一个世界，而不是一个目的，这个世界不会消逝，更不会结束。 “下界、末地都是现实中不存在的东西，如果做下去这个系列很可能会坏掉，所以我选择了结束。” ——籽岷的极限生存系列 - 停更说明 梭罗在瓦尔登湖畔享受自然。在尘世中，找到恬静的场所，并达到梭罗的境界，这对我而言太难了。 于是，在这一刻，Minecraft，成为了我的瓦尔登湖。 配上Minecraft恬静悠长的BGM，我梦见进入了另一个世界，一个属于我自己的世界，我狩猎、我探索、我创造……没有什么成绩单，更没有什么不得不做的事，我就是我。 高考结束，Minecraft 迎来了重大更新版本——水域更新1.13。原本贫瘠荒凉的水下时间充满了生机，从此，我回来了！ 深入游戏内容的探索只是一方面，达到一定程度后，我把目光转向了对游戏机制的探索。 高考结束后的暑假，对村庄机制做了深入的研究后，我研造出了第一款刷铁机，它将全自动地、稳定地产出铁锭。虽然从今天的目关看，当初的刷铁机设计有相当多的可优化之处，但对我而言，这是一个重要的转折： 我可以在Minecraft中提出问题，根据Minecraft的游戏内容分析问题，利用Minecraft的游戏机制解决问题。 在Minecraft中，能够限制你的，只有想象力与行动力。 从初版的刷铁机开始，我逐渐做出了全自动农田、刷金塔等自动化设施。可能是我比较喜欢动脑，我非常享受这种：为解决一个问题而不断思考、实施、改进的过程。 此后，随着不断的实践与积累，了解了不少的游戏机制，学到了不少红石知识，而为了更加深入的了解红石，甚至学起了一些数字电路的知识…… Minecraft的玩法多样，但每一种玩法深入下去，都将是一门深刻的学问。先前对Minecraft的理解太少了、太单纯了。 在现实世界遇到压力时，来到Minecraft——瓦尔登湖畔享受静谧的时光；而每当脑海中萌生新的想法，来到Minecraft，将想法用于实践。这便是Minecraft，当然，这只是它的冰山一角。 当下在许多课程中，我也夹带了不少Minecraft私货：算法分析小班课上讲了Minecraft中的匈牙利算法，JAVA课的大作业是小型的Minecraft，微电子与电路基础的期末展示是在Minecraft中利用红石搭建出的8-bit乘法器…… 在PKU，很幸运遇到了同样喜欢Minecraft的同学，在PKUMC愉快水群与在AstroMC不断修建，累了与MC享受宁静，无聊了在MC思考超越，这便是当下的MC。 或许有时，很长一段时间我不会点开它，但它给我带来的快乐、满足、收获是存在的。 Minecraft，是一款游戏，是我的瓦尔登湖。可能会有一天，我将永久地离开瓦尔登湖畔，但在那的回忆，永远不会消散。 最后，想以终末之诗作为结尾： And the game was over and the player woke up from the dream. And the player began a new dream. And the player dreamed again, dreamed better. And the player was the universe. And the player was love.曲终人散，黄粱一梦。玩家开始了新的梦境。玩家再次做起了梦，更好的梦。玩家就是宇宙。玩家就是爱。 You are the player.你就是那个玩家。 Wake up.该醒了。","link":"/2020/12/17/Minecraft-and-Me/"},{"title":"【终结】一份傅里叶笔记","text":"注：本文作者为@IcyChlorine，由于目前IcyChlorine尚未建立起个人网站，因此将内容暂时挂载到我的博客中。本文依旧使用CC BY-NC-SA 4.0协议，但署名时请署名为IcyChlorine。 2021.04.06更新：原贴地址：Fourier方法专栏-二-从傅里叶级数到傅里叶变换 IcyChlorine 2020-12-14 写在前面自从大一学了傅里叶级数（并且没学好），大二的数理方法又错过了讲傅里叶变换的那节课（数理方法），就一直对傅里叶变换感觉懵懵懂懂，没学进去；虽然道理能搞懂、公式能照搬，但用起来总是没有信心；再加之傅里叶变换的具体方法和公式种类繁多，有时更让我摸不着头脑。由于计算物理要讲FFT,便打算趁这个机会查缺补漏，把傅里叶变换没有搞懂的地方彻底搞懂（指我自己的问题），整理成笔记。 这份笔记的内容应该包括： 从傅里叶级数到傅里叶变换的”推导“（是如何过渡过去的？） 这里便会牵涉到各种不同的傅里叶公式 关于傅里叶级数敛散性的一些讨论（刘旭峰留下的坑，看了伍胜健的数分II中的相关内容才明白） 卷积的推导 从傅里叶级数到傅里叶变换在高数课本中，给出的傅里叶级数公式为：$$f(x)=\\frac{a_0}{2}+\\sum_{n=1}^\\infty (a_n\\cos nx+b_n \\sin n_x)$$ ​ 简单起见，我们假设函数没有瑕点，级数总能收敛 其中系数由积分给出： $$a_n=\\frac{1}{\\pi}\\int_\\pi^\\pi f(x)\\cos nx \\mathrm{d}x$$ $$b_n=\\frac{1}{\\pi}\\int_\\pi^\\pi f(x)\\sin nx \\mathrm{d}x$$ 这是来自于三角函数系的正交性: $$\\langle \\cos mx|\\cos nx\\rangle=\\pi\\delta_{mn},\\langle \\sin mx|\\sin nx\\rangle=\\pi\\delta_{mn}$$ $$\\langle \\cos mx|\\sin nx\\rangle=0$$ 这个结果看上去非常美丽，但却仍有一些问题： 为什么$n=0$的项要搞特殊？强迫症很痛苦啊！ 进一步来说，从数学上，为什么$n=0$的项很特殊呢？(显然我并不满足那个简单的定积分公式) 所有三角函数看上去还是有点冗余/复杂. 这个形式要求$f(x)$必须是以$2\\pi$为周期的函数，对一般函数不太好处理 这个形式很不容易推广/过渡到傅里叶变换上. 所幸我这两天发现了一个惊天秘密,可以解决这些问题. 简单起见,我们首先来看余弦项,把正弦项扔掉(或者说假定函数是偶函数): $$ f(x)=\\sum_{n=-\\infty}^{-1}\\frac{a_n}{2}\\cos nx+\\frac{a_0}{2}+\\sum_{n=1}^{\\infty}\\frac{a_n}{2}\\cos nx=\\sum_{n=-\\infty}^\\infty \\frac{a_n}{2}\\cos nx$$ 瞬间就统一了啊有木有!看看那个该死的$a_0$为什么要搞特殊…一下子就看清楚了. 但是问题还没有结束…这种trick对正弦项来说并没有什么卵用;事实上,它是不可推广的.事实^2上——上式更好的用法是当作一个不严谨的insight,作为一个入口.我们一会儿会回来再看一个式子. 更好的做法是,先向复数推广,我们考虑下列复数的傅里叶级数: $$\\sum_{n=-\\infty}^{\\infty}e_ne^{inx}$$ 函数系$(e^{inx})_{n=-\\infty}^{+\\infty}$的正交性比三角函数系更有意思,也更令强迫症满意: $$\\langle e^{imx}|e^{inx}\\rangle=\\int_{-\\pi}^{\\pi}e^{imx}e^{inx}\\mathrm{d}x=\\int_{-\\pi}^{\\pi}e^{i(m+n)x}\\mathrm{d}x\\\\=\\frac{1}{i(m+n)}e^{i(m+n)x}|_{-\\pi}^\\pi$$ 等等,这怎么好像和我们以前看到的不对? 啊,让第二个指数项的指数加个负号就对了…这不就是共轭内积的定义吗!大师我悟了!(指内积为什么要定义成共轭内积的样子——不然,以这个粒子为例,指数函数系的正交性就无法得出了) 改变后的式子为: $$\\langle e^{imx}|e^{inx}\\rangle=\\int_{-\\pi}^{\\pi}e^{imx}e^{-inx}\\mathrm{d}x=\\int_{-\\pi}^{\\pi}e^{i(m-n)x}\\mathrm{d}x\\\\=\\frac{1}{i(m-n)}e^{i(m-n)x}|_{-\\pi}^\\pi=\\frac{1}{i(m-n)}[e^{i(m-n)\\pi}-e^{i(m-n)-\\pi}]=\\frac{2}{m-n}\\sin (m-n)\\pi=0$$ 当然,看到分母上的$m-n$后,我立马反应过来,这应该是$m\\neq n$时的情况…对于$m=n$的情况,应该是: $$\\langle e^{inx}|e^{inx}\\rangle=\\int_{-\\pi}^\\pi e^{inx}e^{-inx}\\mathrm{d} x=\\int_{-\\pi}^\\pi 1\\ \\mathrm{d}x=2\\pi$$ 于是统合起来就得到:$\\langle e^{imx}|e^{inx}\\rangle=2\\pi\\delta_{mn} $ 值得注意的是: 这里的$mn$是任意整数,不需要是正数;这比三角函数系前进了一大步 这里的模长是$2\\pi$而不是三角函数的$\\pi$,这是很关键的 事实上,这是由于$e^{inx}e^{-imx}=(\\cos nx+i\\sin nx)(\\cos mx-i\\sin mx)=\\cos nx\\cos mx+\\sin nx\\sin mx$造成的;”共轭”这一关键因素保证了另两项是相消的 于是我们可以写出复数形式的,函数的傅里叶级数: $$f(x)=\\sum^\\infty_{n=-\\infty}e_ne^{inx}$$ 其中 $$e_n=\\frac{1}{2\\pi}\\int_{-\\pi}^\\pi f(x)(e^{inx})^*\\mathrm{d}x=\\frac{1}{2\\pi}\\int_{-\\pi}^\\pi f(x)e^{-inx}\\mathrm{d}x=\\frac{\\langle f(x)|e^{inx}\\rangle}{\\langle e^{inx}|e^{inx}\\rangle}$$ 一般来说,$c_n$可以是复数. 为了加深对复数形式和三角形式的级数之间的关系的理解,我们再做一讨论.还记得前面那个被展开的三角形式傅里叶级数吗?我们换一种形式向负数展开: $$f(x)=\\sum_{n=-\\infty}^\\infty(c_n\\cos nx+s_n\\sin nx)\\\\=\\sum_{n=-\\infty}^\\infty(e_n\\cos nx+ie_n\\sin nx)$$ 于是,我们两边都可以得到系数关系(两种级数展开都具有唯一性,不难发现,于是可以比较系数):$$\\begin{cases}c_{-n}+c_n=a_n,c_0=a_0\\\\-s_{-n}+s_n=b_n\\end{cases},\\begin{cases}c_n=e_n\\\\s_n=ie_n\\end{cases}$$由右边可以得到$s_n=ic_n$,带入左边的下面一式,就可以得到$c_n$的方程组:$$\\begin{cases}c_{n}+c_{-n}=a_n,c_0=a_0\\\\c_n-c_{-n}=-ib_n\\end{cases},s_n=ic_n$$ 由这一式,我们就可以由三角形式的傅里叶级数解出复指数形式的傅里叶级数(的系数),从而建立起了二者之间的联系. 作为特例,当函数为偶函数时,正弦项$b_n$全为零,有$c_n=c_{-n}$,于是就可以得到之前所说的$c_n=\\frac{a_n}{2}$的形式,通过将正数那边的级数翻转一半到负数上,并使得形式统一(没错,指的就是$a_0/2$你这个兔崽子).这时的$s_n=ic_n=ia_n/2$,正数和负数上的部分相互抵消.这里是对前面的那个坑的交代 可以看到,从实到复、指标从正数(或者说自然数)推广到整数的过程是并不trivial的.两种形式下的系数关系略复杂(由线性方程组确定),在偶函数这个特例里有一个比较简单的形式. 指标从正数推广到整数(后面就会看到,这一步是推广到傅里叶变换的不可或缺的一步),很巧地,随着[从实到复]的推广过程自动完成了.这是我始料未及的.这在一定程度上源自于指数函数系$(e^{inx})_{n=-\\infty}^\\infty$在整个整数域(而不仅仅是正数)上的正交性. 另一方面,总体来说复指数形式的一切都比较简单,更具有数学的美和简洁.这表面上源自于指数含数系更好(更统一、更扁平)的正交性,根本上则来源于[一个复数天然地包括了两个实数,能携带比单个实数更多的信息]这一性质本身.指数函数通过欧拉公式统括了正弦和余弦两个函数,并使得最终的公式更为简洁. 从三角形式到复指数形式,我们已经向前迈进了一大步;但能处理的函数仍然仅限于周期为$2\\pi$的函数. 事实上,对于具有任意周期$2T$的函数,我们只要进行变换$x=\\frac{T}{\\pi}\\hat{x}$ ,就可以很方便的构造出以$\\hat{x}$为自变量、以$2\\pi$为周期的函数:$g(\\hat{x})=f(\\frac{T}{\\pi}\\hat{x})=f(x)$.相应地,复指数傅里叶级数及其系数的生成公式为: $$g(\\hat{x})=\\sum^\\infty_{n=-\\infty}e_ne^{in\\hat{x}},\\quad e_n=\\frac{1}{2\\pi}\\int_{-\\pi}^\\pi g(\\hat{x})e^{-in\\hat{x}}\\mathrm{d}\\hat{x}$$ 变换回$f(x)$的结果是: $$f(x)=\\sum^\\infty_{n=-\\infty}e_ne^{i\\frac{n\\pi}{T}x}\\\\ e_n=\\frac{1}{2\\pi}\\int_{-\\pi}^\\pi f(x)e^{-i\\frac{n\\pi}{T}x}\\mathrm{d}(\\frac{\\pi}{T}x)=\\frac{1}{2T}\\int_{-T}^T f(x)e^{-i\\frac{n\\pi}{T}x}\\mathrm{d}x$$ 若令$k=\\frac{n\\pi}{T}$,我们可以得到另一种等价的形式. 到这里,我们完成了从定长周期到一般周期的推广.从针对周期函数的傅里叶级数到针对任意函数的傅里叶变换,一个常用的想法是设想$T\\to\\infty$;所幸在我们的充分的前期铺垫下,这一步会是很容易完成的. 令$T\\to\\infty$,则$f(x)$就愈发和任意函数接近;随着$T$作为分母愈发增大,$\\frac{n\\pi}{T}$就愈发稠密、愈发接近一个连续的谱.将前述和式过渡到连续的积分形式,就有: $$f(x)=\\sum^\\infty_{n=-\\infty}e_ne^{i\\frac{n\\pi}{T}x}\\to \\int_{-\\infty}^\\infty F(n)e^{i\\frac{n\\pi}{T}x}\\mathrm{d}n\\\\F(n)=\\frac{1}{2T}\\int_{T}^T f(x)e^{-i\\frac{n\\pi}{T}x}\\mathrm{d}x\\to\\frac{1}{2T}\\int_{-\\infty}^\\infty f(x)e^{-i\\frac{n\\pi}{T}x}\\mathrm{d}x$$ 式中$F(n)\\in\\mathbb{C}$是$e_n$连续化的结果;其自变量$n$与$e_n$的下标是一致的,函数的意义是在”$n$空间”中的”模式密度”. 实际情况中,我们常常再进行一次变换,以图在变量更为简介的$k$下进行傅里叶变换: $$f(x)\\to\\int_{-\\infty}^\\infty F(k)e^{ikx}\\mathrm{d}k$$ 这对$F(k),F(n)$间提出了约束关系(注意,这说明了为什么二者会差一个系数):$F(n)\\mathrm{d}n=F(k)\\mathrm{d}k$ 考虑到$k=\\frac{\\pi}{T}x\\Leftrightarrow \\mathrm{d}k=\\frac{\\pi}{T}\\mathrm{d}n$,带入上式我们就有$F(k)=F(n)\\frac{\\mathrm{d}n}{\\mathrm{d}k}=F(n)\\frac T\\pi$,再带回傅里叶展开式就有: $$F(k)=\\frac T\\pi F(n)=\\frac1{2\\pi}\\int_{-\\infty}^\\infty f(x)e^{-ikx}\\mathrm{d}k\\\\f(x)=\\int_{-\\infty}^\\infty F(k)e^{ikx}\\mathrm{d}k$$ -OHHHHHHHHHHHHHHHHHHHHH!至此,我们已经完整地推出了/过渡到了傅里叶变换的公式.值得注意的几点包括: 这里的波数$k=\\frac{n\\pi}T$作为数学定义出现,但仍然是与物理定义一致的 随着$T$趋于无穷,作为波数的$k=\\frac{n\\pi}{T}$的取值点也愈发稠密;只要考虑$F(k)$是连续函数,我们总可以在那些无理点和没有取值的有理点补充定义,将值补充定义为附近的有取值的$\\frac{n\\pi}{T}$点,获得一个完整的连续函数.这样一来,说明$F(k)$”定义是合理的”. 通过这样推导得出的傅里叶变换,我们自然而然地解决了正向变换中那个奇怪的负号问题($e^{-ikx}$)——它来自于复函数空间上的酉内积. 此外,经有这一推导,我们还自然地得出了傅里叶逆变换的公式.它与正向变换的公式差了一个负号.(表面看上去是这样.) 一些书中为了对称性(说的就是你,《数学物理方法》),会采用另一种写法,将正逆傅里叶变换中前面的系数统一写为$1/\\sqrt{2\\pi}$,但这只是些符号上的trick,其公式的其他部分、以及背后的数学思想,都是一致的. 总结一下.以上3000字,我们完成了这么几件事: 将三角形式傅里叶级数拓展为复指数形式傅里叶级数 从实到复的拓展$\\mathbb{R}\\to\\mathbb{C}$ 求和指标从自然数向整数的拓展$n\\in\\mathbb{N}\\to\\mathbb{Z}$ 将固定周期函数的傅里叶级数拓展为任意周期函数的傅里叶级数 $(-\\pi,\\pi)\\to(-T,T)$ 将离散的傅里叶级数拓展为连续的傅里叶变换(及其逆变换) 从属于离散整数集的求和指标,拓展为属于连续的实数集的积分变量:$n\\in \\mathbb{Z}\\to k\\in \\mathbb{R}$ 通过极限过程$T\\to+\\infty$完成 因而,这一步拓展中包含了许多不严谨的部分;为$f,F$预设了许多美好的前提.详细严谨的分析还是请参考数学分析. 以下都是挖坑内容…不知道什么时候能填完 常用的傅里叶变换结果(小结论系列)傅里叶级数敛散性的分析,Dirichlet 定理大一上刘旭峰的高数课讲到傅里叶级数那一章时,旭峰上来不讲实用的结论却讲起了一大堆歪歪扭扭的定理;当时的我没有认出其中的几个trick,然后就跟不上,然后就弃疗了,…导致我后来的傅里叶学得一直不好(没有信心是更关键的).直到昨天(2020-12-14),搞了本伍胜健的《数学分析II》仔细研究傅里叶级数一章,回头再翻开旭峰高数的笔记一看,才发现歪歪扭扭地每个定理上都写着”数学分析”几个字. 近日也有能力了(看了数学分析并且看懂了;数学储备也足够了),打算做个笔记把这个历史遗留问题解决掉.(挖坑) 卷积emm下次再说 离散傅里叶(DFT)与快速傅里叶变换(FFT)下次再说，此处有它们间直观关系推导。","link":"/2020/12/14/Notes-of-Fourier-Transform/"},{"title":"输出虚拟地址对应物理地址的程序","text":"这是一个可以在程序内输出本进程中虚拟地址实际对应的物理地址，可以用来探究linux内存管理系统。注意：由于一些原因，此程序未能找到在lab machine上成功运行的方法，因此需要在虚拟机上运行。 文件结构1234vm.h vm.c - 实现了由虚拟地址计算物理地址的函数，请勿修改cow.c - 测试copy on write的程序global.c - 测试.bss段映射匿名文件的程序mmap.c - 测试mmap函数有关操作的程序 其中，vm.h与vm.c核心代码来源于网络，为了方便调用，此处做了适当的微调与封装。 使用方法函数接口在vm.h与vm.c中，封装了一个函数，其可以根据传入的虚拟地址输出物理地址： 1void show_pa(void* va, const char* info); 函数参数va - 需要查看其物理地址的虚拟地址info - 输出时首先输出的字符串，方便查看；如果为空字符串，则改为输出进程号 函数效果会按如下格式输出一行： 1{info}: virtual addr = {va}, physical addr = {pa} 如果info为空串，则{info}会替换为pid = {进程号}；如果物理地址转化成功，则{pa}为16进制物理地址，否则为错误信息（包括缺页、权限不足失败等）。 调用方法新建一个.c文件，包含vm.h头文件后即可直接调用： 1#include &quot;vm.c&quot; 可以在自己的代码中调用此函数观察某些变量的物理地址。 实例：cow.c一个简单的例子，其fork出一个子进程，最初两个进程同一变量的物理地址一致，而父进程写变量时发生写时复制，父进程该变量的物理地址变化。代码如下： 12345678910111213141516171819202122232425/* copy on write */#include&quot;vm.h&quot;#include &lt;stdio.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;int main(){ static int c = 100; int pid = fork(); if(pid == 0){ /* child */ show_pa((void*)&amp;c, &quot;&quot;); sleep(2); show_pa((void*)&amp;c, &quot;&quot;); } else{ /* parent */ sleep(1); show_pa((void*)&amp;c, &quot;&quot;); c = 20; printf(&quot;parent: modified c.\\n&quot;); show_pa((void*)&amp;c, &quot;&quot;); } wait(NULL); return 0;} 编译由于show_pa函数的定义在vm.c中，因此编译命令需要包含vm.c，以编译上述cow.c为例： 1$ gcc cow.c vm.c -g -Wall -o vm 将得到名为vm的可执行文件。 运行 （重要！）如果直接运行出现了如下情况（以上述cow.c编译出的可执行文件vm为例）： 12345pid = 52128: virtual addr = 0x55d38e576010, physical addr = 10pid = 52127: virtual addr = 0x55d38e576010, physical addr = 10parent: modified c.pid = 52127: virtual addr = 0x55d38e576010, physical addr = 10pid = 52128: virtual addr = 0x55d38e576010, physical addr = 10 物理地址最多只有3个16进制数，不足4KB，即只输出了页内偏移。这是权限原因导致的，在lab machine上未能找到解决方案，但在自己的虚拟机/双系统上可以解决。 如果编译出的可执行文件为vm，则可以通过如下指令运行： 12$ sudo setcap cap_sys_admin=eip vm$ sudo ./vm 其中，第一条命令在每次编译后需要运行，若先前已运行过且没有重新编译则不需要。注意：两条命令sudo都是必要的。以此法的运行结果如下（每次运行可能不同）： 12345pid = 52128: virtual addr = 0x55d38e576010, physical addr = 26541010pid = 52127: virtual addr = 0x55d38e576010, physical addr = 26541010parent: modified c.pid = 52127: virtual addr = 0x55d38e576010, physical addr = 52376010pid = 52128: virtual addr = 0x55d38e576010, physical addr = 26541010 可以观察到：父进程52127在修改了变量c的值后发生了写时复制。 更多实例global.c1234567891011121314151617181920212223242526272829303132333435363738394041/* anonymous file and CoW */#include&quot;vm.h&quot;#include&lt;stdio.h&gt;#define LEN 1024#define BUF 1024int array[LEN][LEN];int main(){ char buffer[BUF]; // printf(&quot;array = %p\\n&quot;, array); for(int i = 1; i &lt;= 4; i++){ sprintf(buffer, &quot;array[%d][0]&quot;, i); show_pa(&amp;array[i][0], buffer); /* page not present */ } int sum = 0; for(int i = 0; i &lt; LEN; i++) sum += array[i][0]; /* read but not write */ printf(&quot;sum = %d\\n&quot;, sum);/* Avoid being optimized out */ for(int i = 1; i &lt;= 4; i++){ sprintf(buffer, &quot;array[%d][0]&quot;, i); show_pa(&amp;array[i][0], buffer); /* page present */ } for(int i = LEN - 4; i &lt; LEN; i++){ sprintf(buffer, &quot;array[%d][0]&quot;, i); show_pa(&amp;array[i][0], buffer); /* page present */ } for(int i = 1; i &lt;= 4; i++){ array[i][0] = (i-1)*(i-1); sprintf(buffer, &quot;modified array[%d][0]&quot;, i); show_pa(&amp;array[i][0], buffer); /* copy on write */ } for(int i = LEN - 4; i &lt; LEN; i++){ sprintf(buffer, &quot;array[%d][0]&quot;, i); show_pa(&amp;array[i][0], buffer); /* not changed */ }} 首先定义了一个较大的全局变量int array[1024][1024]，注意array[i][0]与array[i+1][0]正好相差4KB。 之后执行如下过程： 直接查看它们的物理地址（缺页） 经过一趟读操作后查看它们的物理地址 对部分进行写操作后查看它们的物理地址 详细细节请参阅源代码，其可能的输出如下： 123456789101112131415161718192021array[1][0]: virtual addr = 0x55d619f68040, physical addr = page present is 0array[2][0]: virtual addr = 0x55d619f69040, physical addr = page present is 0array[3][0]: virtual addr = 0x55d619f6a040, physical addr = page present is 0array[4][0]: virtual addr = 0x55d619f6b040, physical addr = page present is 0sum = 0array[1][0]: virtual addr = 0x55d619f68040, physical addr = 23f19040array[2][0]: virtual addr = 0x55d619f69040, physical addr = 23f19040array[3][0]: virtual addr = 0x55d619f6a040, physical addr = 23f19040array[4][0]: virtual addr = 0x55d619f6b040, physical addr = 23f19040array[1020][0]: virtual addr = 0x55d61a363040, physical addr = 23f19040array[1021][0]: virtual addr = 0x55d61a364040, physical addr = 23f19040array[1022][0]: virtual addr = 0x55d61a365040, physical addr = 23f19040array[1023][0]: virtual addr = 0x55d61a366040, physical addr = 23f19040modified array[1][0]: virtual addr = 0x55d619f68040, physical addr = 6c06e040modified array[2][0]: virtual addr = 0x55d619f69040, physical addr = 11bb9040modified array[3][0]: virtual addr = 0x55d619f6a040, physical addr = 4f7af040modified array[4][0]: virtual addr = 0x55d619f6b040, physical addr = 75b67040array[1020][0]: virtual addr = 0x55d61a363040, physical addr = 23f19040array[1021][0]: virtual addr = 0x55d61a364040, physical addr = 23f19040array[1022][0]: virtual addr = 0x55d61a365040, physical addr = 23f19040array[1023][0]: virtual addr = 0x55d61a366040, physical addr = 23f19040 注意到，在经历读写操作前是缺页状态（前4行array[1][0]-array[4][0]），但修改程序后发现array[0][0]在读写前并未缺页，请思考可能的原因。 mmap.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&quot;vm.h&quot;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/mman.h&gt;#include&lt;sys/wait.h&gt;int main(){ char* private1 = (char*)mmap(0, 128, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, 0, 0); char* private2 = (char*)mmap(0, 128, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, 0, 0); char* shared = (char*)mmap(0, 128, PROT_READ|PROT_WRITE, MAP_ANON|MAP_SHARED, 0, 0); show_pa(private1, &quot;private1&quot;); /* not present */ show_pa(private2, &quot;private2&quot;); /* not present */ show_pa(shared, &quot;shared&quot;); /* not present */ printf(&quot;char: %d %d %d\\n&quot;, (int)private1[0], (int)private2[0] ,(int)shared[0]); /* read */ show_pa(private1, &quot;private1&quot;); show_pa(private2, &quot;private2&quot;); /* private1 = private2 */ show_pa(shared, &quot;shared&quot;); /* shared != private*/ private2[0] = 'a'; printf(&quot;modified private2\\n&quot;); show_pa(private2, &quot;private2&quot;); /* copy on write */ private1[0] = 'b'; printf(&quot;modified private1\\n&quot;); show_pa(private1, &quot;private1&quot;); /* changed */ shared[0] = 'A'; printf(&quot;modified shared\\n&quot;); show_pa(shared, &quot;shared&quot;); /* not changed */ printf(&quot;fork!\\n&quot;); int pid = fork(); if(pid){ /* parent */ show_pa(private1, &quot;[parent]private1&quot;); show_pa(shared, &quot;[parent]shared&quot;); sleep(2); /* step 2 */ show_pa(private1, &quot;[parent]private1&quot;); /* not changed */ show_pa(shared, &quot;[parent]shared&quot;); /* not changed */ printf(&quot;[parent]private1 = %c, shared = %c\\n&quot;, private1[0], shared[0]);/* private1 not changed, shared changed*/ private1[0] = 'x'; printf(&quot;[parent]modified private1\\n&quot;); show_pa(private1, &quot;[parent]private1&quot;); /* not changed (refcnt==1)*/ }else{ /* child */ show_pa(private1, &quot;[child]private1&quot;); show_pa(shared, &quot;[child]shared&quot;); /* not present */ volatile char c = shared[0]; /* read */ show_pa(shared, &quot;[child]shared&quot;); /* same as parent */ sleep(1); /* step 1 */ private1[0] = 'c'; printf(&quot;[child]modified private1\\n&quot;); shared[0] = c + 1; printf(&quot;[child]modified shared\\n&quot;); printf(&quot;[child]private1 = %c, shared = %c\\n&quot;, private1[0], shared[0]); show_pa(private1, &quot;[child]private1&quot;); /* copy on write */ show_pa(shared, &quot;[child]shared&quot;); /* not changed */ } wait(0); return 0;} 此程序mmap了两个私有页与一个共享页，并通过fork观察私有页与共享页在写时复制的区别，具体过程请见源代码。 值得注意的是，此程序fork后，子进程先写私有页触发写时复制，而后父进程写同一变量时并未发生复制，这表明内核维护了私有页面的引用数，若引用数为1则不会复制。 以下是一个可能的输出： 1234567891011121314151617181920212223242526272829private1: virtual addr = 0x7fb9ab92c000, physical addr = page present is 0private2: virtual addr = 0x7fb9ab92b000, physical addr = page present is 0shared: virtual addr = 0x7fb9ab92a000, physical addr = page present is 0char: 0 0 0private1: virtual addr = 0x7fb9ab92c000, physical addr = 23f19000private2: virtual addr = 0x7fb9ab92b000, physical addr = 23f19000shared: virtual addr = 0x7fb9ab92a000, physical addr = 11a64000modified private2private2: virtual addr = 0x7fb9ab92b000, physical addr = 43336000modified private1private1: virtual addr = 0x7fb9ab92c000, physical addr = 71994000modified sharedshared: virtual addr = 0x7fb9ab92a000, physical addr = 11a64000fork![parent]private1: virtual addr = 0x7fb9ab92c000, physical addr = 71994000[parent]shared: virtual addr = 0x7fb9ab92a000, physical addr = 11a64000[child]private1: virtual addr = 0x7fb9ab92c000, physical addr = 71994000[child]shared: virtual addr = 0x7fb9ab92a000, physical addr = page present is 0[child]shared: virtual addr = 0x7fb9ab92a000, physical addr = 11a64000[child]modified private1[child]modified shared[child]private1 = c, shared = B[child]private1: virtual addr = 0x7fb9ab92c000, physical addr = 1e920000[child]shared: virtual addr = 0x7fb9ab92a000, physical addr = 11a64000[parent]private1: virtual addr = 0x7fb9ab92c000, physical addr = 71994000[parent]shared: virtual addr = 0x7fb9ab92a000, physical addr = 11a64000[parent]private1 = b, shared = B[parent]modified private1[parent]private1: virtual addr = 0x7fb9ab92c000, physical addr = 71994000 附录vm.h12345678/** * show physical address of given va * params: * va - vitural address * info - a string will be printed at beginning, current * process id will be printed instead if empty*/void show_pa(void* va, const char* info); vm.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* Do not modify this file unless you know what you are doing */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define MAXBUF 1024//计算虚拟地址对应的地址，传入虚拟地址vaddr，通过paddr传出物理地址static const char* mem_addr(unsigned long vaddr, unsigned long *paddr){ int pageSize = getpagesize();//调用此函数获取系统设定的页面大小 unsigned long v_pageIndex = vaddr / pageSize;//计算此虚拟地址相对于0x0的经过的页面数 unsigned long v_offset = v_pageIndex * sizeof(uint64_t);//计算在/proc/pid/page_map文件中的偏移量 unsigned long page_offset = vaddr % pageSize;//计算虚拟地址在页面中的偏移量 uint64_t item = 0;//存储对应项的值 int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);//以只读方式打开/proc/pid/page_map if(fd == -1)//判断是否打开失败 { return &quot;open /proc/self/pagemap error&quot;; } if(lseek(fd, v_offset, SEEK_SET) == -1)//将游标移动到相应位置，即对应项的起始地址且判断是否移动失败 { return &quot;sleek error&quot;; } if(read(fd, &amp;item, sizeof(uint64_t)) != sizeof(uint64_t))//读取对应项的值，并存入item中，且判断读取数据位数是否正确 { return &quot;read item error&quot;; } if((((uint64_t)1 &lt;&lt; 63) &amp; item) == 0)//判断present是否为0 { return &quot;page present is 0&quot;; } uint64_t phy_pageIndex = (((uint64_t)1 &lt;&lt; 55) - 1) &amp; item;//计算物理页号，即取item的bit0-54 *paddr = (phy_pageIndex * pageSize) + page_offset;//再加上页内偏移量就得到了物理地址 return &quot;&quot;;}void show_pa(void* va, const char* str){ unsigned long pa = -1; const char* msg = mem_addr((unsigned long)va, &amp;pa); if(strlen(str) == 0) printf(&quot;pid = %d: virtual addr = %p, &quot;, getpid(), va); else printf(&quot;%s: virtual addr = %p, &quot;, str, va); if(strlen(msg)) printf(&quot;physical addr = %s\\n&quot;, msg); else printf(&quot;physical addr = %lx\\n&quot;, pa);}","link":"/2020/12/14/physical-address/"},{"title":"DFS, DTFT与DFT","text":"这篇博客是为了便于直观理解各种傅里叶级数/变换公式的得来，必须指出：本文的推导在数理上是不严谨的。 关于连续傅里叶级数与变换的数理推导与关系，请参阅@IcyChlorine所写的笔记【终结】一份傅里叶笔记。 DFS: 离散傅里叶级数适用情形：对于周期为$N$的离散周期序列$\\widetilde{x}(n)$$$\\begin{cases}\\widetilde{x}(n)=IDFS[\\widetilde{X}(k)]=\\sum_{k=0}^{N-1}\\widetilde{X}(k)e^{j\\frac{2\\pi}{N}kn} \\\\\\widetilde{X}(k)=DFS[\\widetilde{x}(n)]=\\frac1N\\sum_{n=0}^{N-1}\\widetilde{x}(n)e^{-j\\frac{2\\pi}{N}kn}\\end{cases}$$ 形式对于连续傅里叶级数，有：$$\\widetilde{f}(t)=\\sum_{k=-\\infty}^{\\infty}F_ne^{jk\\omega_0t}$$由$t\\to n,T\\to N,\\omega_0=\\frac{2\\pi}{N}$，则离散DFT的形式为：$$\\widetilde{x}(n)=\\sum_{k=-\\infty}^{\\infty}\\widetilde{X}(k)e^{j\\frac{2\\pi}{N}kn}$$ 注意到，$e$指数部分以$N$为周期，因此作退化，得到DFS形式：$$\\widetilde{x}(n)=\\sum_{k=0}^{N-1}\\widetilde{X}(k)e^{j\\frac{2\\pi}{N}kn}$$ 系数PPT上对离散情形的系数做了严格的数学推导，但过程比较晦涩，这里依然采用连续情形进行类比，但在数理上这是不严谨的。 依然考虑连续情形，系数：$$F_n=\\frac1T\\int_{t_0}^{T+t_0}\\widetilde{f}(t)e^{-jn\\omega_0t}dt$$由$t\\to n,T\\to N,\\omega_0=\\frac{2\\pi}{N}$，则离散DFT的系数：$$\\widetilde{X}(k)=\\frac1N\\sum_{n=0}^{N-1}\\widetilde{x}(n)e^{-j\\frac{2\\pi}{N}kn}$$事实上，$\\widetilde{X}(k)$也是以$N$为周期的序列。 DTFT: 离散时域傅里叶变换将DFS推广到非周期情形，即$N\\to\\infty$，则得到DTFT。 $$\\begin{cases}X(e^{j\\omega})=DTFT[x(n)]=\\sum_{n=-\\infty}^{\\infty}x(n)e^{-j\\omega n} \\\\x(n)=IDTFT[X(e^{j\\omega})]=\\frac1{2\\pi}\\int_{-\\pi}^{\\pi}X(e^{j\\omega})e^{j\\omega n}d\\omega\\end{cases}$$正变换将离散序列变换为连续信号，而反变换将离散信号变换为连续信号。 正变换周期信号的DFS：$$\\widetilde{X}(k)=\\frac1N\\sum_{n=0}^{N-1}\\widetilde{x}(n)e^{-j\\frac{2\\pi}{N}kn}$$取$N\\to\\infty$，有$\\frac{2\\pi}Nk\\to\\omega$，得到：$$\\lim\\limits_{N\\to \\infty}N\\widetilde{X}(k)=\\sum_{n=-\\infty}^{\\infty}x(n)e^{-j\\omega n}$$由于$n$为整数，因此对于上式右侧，$\\omega$以$2\\pi$为周期，从而可以改写上式左侧、记$\\lim\\limits_{N\\to \\infty}N\\widetilde{X}(k)=X(e^{j\\omega})$，则得到正变换：$$X(e^{j\\omega})=\\sum_{n=-\\infty}^{\\infty}x(n)e^{-j\\omega n}$$ 逆变换取$N\\to\\infty$，比对$X(e^{j\\omega})$与$\\widetilde{X}(k)$：$$\\widetilde{X}(k)=\\frac1N\\sum_{n=0}^{N-1}\\widetilde{x}(n)e^{-j\\frac{2\\pi}{N}kn}=\\frac1N\\sum_{n=-\\infty}^{\\infty}x(n)e^{-jk\\omega_0 n}=\\frac1NX(e^{jk\\omega_0})$$值得注意的是：上述等式将在进行单周期傅里叶变换时严格成立。带入$\\widetilde{x}(n)$的表达式，得到：$$\\widetilde{x}(n)=\\frac1N\\sum_{k=0}^{N-1}X(e^{jk\\omega_0})e^{j\\omega_0kn}=\\frac1{2\\pi}\\sum_{k=0}^{N-1}X(e^{jk\\omega_0})e^{j\\omega_0kn}\\omega_0$$再次取极限，得出反变换式：$$x(n)=\\frac1{2\\pi}\\int_{-\\pi}^{\\pi}X(e^{j\\omega})e^{j\\omega n}d\\omega$$注：由于$k\\omega_0$在$2\\pi$范围内变化，因此积分区间是$2\\pi$. 事实上，将正变换带入上式，发现等式成立。 周期信号情形不妨设$X(e^{j\\omega})=2\\pi\\sum_{r=-\\infty}^{\\infty}\\delta(\\omega-\\omega_0+2\\pi r)$，带入IDTFT有：$$x(n)=\\frac1{2\\pi}\\int_{-\\pi}^{\\pi}X(e^{j\\omega})e^{j\\omega n}d\\omega=e^{j\\omega_0n}$$这是一个周期函数，由此最终可推导出周期信号下的DTFT：$$DTFT(\\widetilde{x}[n])=2\\pi\\sum_{k=-\\infty}^{\\infty}\\widetilde{X}(k)\\delta(\\omega-\\frac{2\\pi k}{N})$$将其中冲激函数的权重记作$X(e^{j\\omega})$，则有：$$X(e^{j\\omega})=2\\pi\\widetilde{X}(k),~{\\omega=\\frac{2\\pi}{N}k}$$单周期傅里叶变换时，有如下严格的等式：$$\\widetilde{X}(k)=\\frac1NX_0(e^{jk\\omega_0})=\\frac1N\\left.X_0(e^{j\\omega})\\right|_{\\omega=\\frac{2\\pi}{N}k}$$ 因此DTFT中$\\delta$函数的系数，相当于对单周期DTFT进行抽样：$$X(e^{j\\omega})=\\omega_0\\left.X_0(e^{j\\omega})\\right|_{\\omega=\\frac{2\\pi}{N}k}$$ 应当指出，以上过程的$\\delta$函数是连续情形的$\\delta(x)$，而非离散的$\\delta[n]$。 DFT：离散傅里叶变换这是方便计算机处理而诞生的变换，没有物理意义。$$\\begin{cases}X(k)=DFT[x(n)]=\\sum_{n=0}^{N-1}x(n)e^{-j\\frac{2\\pi}{N}kn} \\\\x(n)=IDFT[X(k)]=\\frac1N\\sum_{k=0}^{N-1}X(k)e^{j\\frac{2\\pi}{N}kn}\\end{cases}$$其中，正变换可以看做：单周期（或主值序列）傅里叶变换在离散间隔的采样。在数学上，它是离散傅里叶级数的$N$倍，或者正比于离散周期信号DTFT在$\\delta$函数前的系数。","link":"/2020/11/28/Fourier-Transform/"},{"title":"递归定理——输出自身源代码的程序","text":"递归定理的一个重要推论，便是对于任意一个程序（图灵机），其都可以在内部获得自身的表述。用程序设计的语言：任意一个程序，都能够在程序内部的某个部分获得自身的源代码。 递归定理的定理内容：咕着 根据递归定理的内容，下面的python程序展示了：如何在任意程序的内部某个部分获取自己的源代码： 1234567891011# 代码段Ad, n, s, A = chr(35), chr(10), chr(39)*3, '''print(&quot;{} 代码段A{}{}d, n, s, A = chr(35), chr(10), chr(39)*3, {}{}{}&quot;.format(d, n, n, s, A, s))print(A)print(&quot;{} 代码段B&quot;.format(d))'''print(&quot;{} 代码段A{}{}d, n, s, A = chr(35), chr(10), chr(39)*3, {}{}{}&quot;.format(d, n, n, s, A, s))print(A)print(&quot;{} 代码段B&quot;.format(d))# 代码段B 上述python程序的输出是其自身的源代码： 1234567891011# 代码段Ad, n, s, A = chr(35), chr(10), chr(39)*3, '''print(&quot;{} 代码段A{}{}d, n, s, A = chr(35), chr(10), chr(39)*3, {}{}{}&quot;.format(d, n, n, s, A, s))print(A)print(&quot;{} 代码段B&quot;.format(d))'''print(&quot;{} 代码段A{}{}d, n, s, A = chr(35), chr(10), chr(39)*3, {}{}{}&quot;.format(d, n, n, s, A, s))print(A)print(&quot;{} 代码段B&quot;.format(d))# 代码段B 为了处理井号、引号与换行符的转义问题，此处将对应字符的ascii码存入对应变量，在print过程中输出对应字符变量来实现。","link":"/2020/11/24/Recusive-Theorem/"},{"title":"Minecraft终末之诗","text":"终末之诗(End Poem)将在玩家击败末影龙后，首次进入终末之地的返回传送门时，以滚动字幕的形式出现在玩家的屏幕上，全长9分28秒。随后将播放鸣谢名单，共计27分15秒。 终末之诗取自两个未知的谈论者之间讨论玩家的功绩的对话（普遍认为是两个末影人），放送过程中以Alpha作为背景音乐。 终末之诗全文中文翻译及本文其他部分内容来自Minecraft Wiki，使用CC BY-NC-SA 3.0协议。 剧透警告：由于终末之诗于达到具有象征意义的游戏阶段后出现，在实际游玩前阅读可能会降低你对亲自发现游戏秘密的乐趣。 终末之诗BGM： End Poem 终末之诗I see the player you mean.我看到你所指的那位玩家了。 [Playername]?[玩家名称]? Yes. Take care. It has reached a higher level now. It can read our thoughts.是的。小心。他已达到了更高的境界。他能够阅读我们的思想。 That doesn’t matter. It thinks we are part of the game.无伤大雅。他认为我们是游戏的一部分。 I like this player. It played well. It did not give up.我喜欢这个玩家。他玩得很好。他从未放弃。 It is reading our thoughts as though they were words on a screen.他以屏幕上出现的文字的形式阅读着我们的思想。 That is how it chooses to imagine many things, when it is deep in the dream of a game.在他深陷游戏梦境中时，他总以这种方式想象出形形色色的事物。 Words make a wonderful interface. Very flexible. And less terrifying than staring at the reality behind the screen.文字是种美妙的界面。非常灵活。且比凝视着屏幕后的现实要更好。 They used to hear voices. Before players could read. Back in the days when those who did not play called the players witches, and warlocks. And players dreamed they flew through the air, on sticks powered by demons.他们也曾经听到过声音。在玩家能够阅读之前。君不见那些不曾游玩的人们称呼玩家为女巫，和术士。而玩家们梦见他们自己乘坐在被恶魔施力的棍子上，在空气中翱翔。 What did this player dream?这个玩家梦见了什么？ This player dreamed of sunlight and trees. Of fire and water. It dreamed it created. And it dreamed it destroyed. It dreamed it hunted, and was hunted. It dreamed of shelter.他梦见了阳光和树。梦见了火与水。他梦见他创造。他亦梦见他毁灭。他梦见他狩猎，亦被狩猎。他梦见了庇护所。 Hah, the original interface. A million years old, and it still works. But what true structure did this player create, in the reality behind the screen?哈，那原始的界面。经历一百万年的岁月雕琢，依然长存。但此玩家在那屏幕后的真实里，建造了什么真实的构造？ It worked, with a million others, to sculpt a true world in a fold of the [scrambled], and created a [scrambled] for [scrambled], in the [scrambled].他辛勤地劳作，和其他百万众一起，刻画了一个真实的世界，由[乱码]，且创造了[乱码]，为了[乱码]，于[乱码]中。 It cannot read that thought.他读不出那个思想。 No. It has not yet achieved the highest level. That, it must achieve in the long dream of life, not the short dream of a game.不。他还没有到达最高的境界。那层境界，他必须完成生命的长梦，而非游戏中黄粱一梦。 Does it know that we love it? That the universe is kind?他知道我们爱他么？这个宇宙是仁慈的？ Sometimes, through the noise of its thoughts, it hears the universe, yes.有时，通过他思绪的杂音，他能听到宇宙，是的。 But there are times it is sad, in the long dream. It creates worlds that have no summer, and it shivers under a black sun, and it takes its sad creation for reality.但是有时亦不胜悲伤，于那漫漫长梦中。他创造了没有夏日的世界，在黑日下颤抖着，将自己悲伤的创造视为现实世界。 To cure it of sorrow would destroy it. The sorrow is part of its own private task. We cannot interfere.为他治愈悲伤会摧毁他。而悲伤是他的私人事务。我们不能干涉。 Sometimes when they are deep in dreams, I want to tell them, they are building true worlds in reality. Sometimes I want to tell them of their importance to the universe. Sometimes, when they have not made a true connection in a while, I want to help them to speak the word they fear.有时当他们深陷梦境中时，我想要告诉他们，他们在现实中创造了真实的世界。有时我想告诉他们他们自身对宇宙的重要性。有时，当他们和现实失去了联系，我想帮助他们说出他们所惧怕的话语。 It reads our thoughts.他读出了我们的思想。 Sometimes I do not care. Sometimes I wish to tell them, this world you take for truth is merely [scrambled] and [scrambled], I wish to tell them that they are [scrambled] in the [scrambled]. They see so little of reality, in their long dream.有时我毫不关心。有时我想要告诉他们，你们所认为的真实不过是[乱码]和[乱码]，我想要告诉他们他们是在[乱码]中的[乱码]。于他们的长梦中，他们眼中所见的真实太少了。 And yet they play the game.而他们仍然玩这个游戏。 But it would be so easy to tell them…但很容易就可以告诉他们…… Too strong for this dream. To tell them how to live is to prevent them living.对于这个梦来说太强烈了。告诉他们如何活着就是阻碍他们活下去。 I will not tell the player how to live.我不会告诉这个玩家如何生活的。 The player is growing restless.这个玩家正在变得焦虑。 I will tell the player a story.我会告诉这个玩家一个故事。 But not the truth.但不是真相。 No. A story that contains the truth safely, in a cage of words. Not the naked truth that can burn over any distance.不。是一个严密地将真实包裹起来的文字牢笼。而不是赤裸裸的真相。 Give it a body, again.赋予他主体，再一次。 Yes. Player…好的。玩家…… Use its name.以名字称呼他。 [Playername]. Player of games.[玩家名称]。游戏的玩家。 Good.很好。 Take a breath, now. Take another. Feel air in your lungs. Let your limbs return. Yes, move your fingers. Have a body again, under gravity, in air. Respawn in the long dream. There you are. Your body touching the universe again at every point, as though you were separate things. As though we were separate things.深呼吸，很好。再深呼吸一次。感受空气充盈你的肺叶。让你的四肢回归。是的，运动你的手指。再次感受你的身体，在重力下，在空气中。在长梦中重生。你感受到了。你的身体每时每刻都触摸着宇宙，尽管你是分离的存在。尽管我们是分离的存在。 Who are we? Once we were called the spirit of the mountain. Father sun, mother moon. Ancestral spirits, animal spirits. Jinn. Ghosts. The green man. Then gods, demons. Angels. Poltergeists. Aliens, extraterrestrials. Leptons, quarks. The words change. We do not change.我们是谁？我们曾经被称作高山的精灵。太阳父亲，月亮母亲。古老的英灵，动物的魂魄。神祇。鬼魂。小绿人。而后是神，恶魔，天使。骚灵。外星人，地外生物。轻子，夸克。词语不断地变化。我们始终如一。 We are the universe. We are everything you think isn’t you. You are looking at us now, through your skin and your eyes. And why does the universe touch your skin, and throw light on you? To see you, player. To know you. And to be known. I shall tell you a story.我们是宇宙。我们是一切你认为出离你本体的事物。你现在看着我们，透过你的皮肤和你的眼睛。而为什么宇宙触摸着你的皮肤，向你洒向光芒？是为了看见你，玩家。以及被认知。我应告诉你一个故事。 Once upon a time, there was a player.很久以前，有一个玩家。 The player was you, [Playername].那玩家就是你，[玩家名称] Sometimes it thought itself human, on the thin crust of a spinning globe of molten rock. The ball of molten rock circled a ball of blazing gas that was three hundred and thirty thousand times more massive than it. They were so far apart that light took eight minutes to cross the gap. The light was information from a star, and it could burn your skin from a hundred and fifty million kilometres away.有时他认为自己是那不断旋转的球体上一层薄薄的熔化的岩石上的人类。那融化的岩石球环绕着一个质量大他三十三万倍的炫目气体球旋转。他们是相隔得如此之远，以至于光需要八分钟才能穿越那空隙。那光是来自一颗恒星的信息，他能够在一亿五千万公里外烧灼你的皮肤。 Sometimes the player dreamed it was a miner, on the surface of a world that was flat, and infinite. The sun was a square of white. The days were short; there was much to do; and death was a temporary inconvenience.有时这个玩家梦见他是一个在一个平的，无限延展的世界表面上的矿工。那太阳是一个方形的白点。昼夜交替很快；要做的事情也很多；死亡亦只是暂时和不方便的。 Sometimes the player dreamed it was lost in a story.有时这玩家梦见他迷失在了一个故事里。 Sometimes the player dreamed it was other things, in other places. Sometimes these dreams were disturbing. Sometimes very beautiful indeed. Sometimes the player woke from one dream into another, then woke from that into a third.有时这玩家梦见他成为了其他的事物，在其他地方。有时这些梦是扰人的。有些则实在很美。有时这个玩家从一个梦中醒来，发现自己落入了第二个梦，却终究是在第三个梦中。 Sometimes the player dreamed it watched words on a screen.有时这个玩家梦见他在屏幕上看着文字。 Let’s go back.让我们回退一点。 The atoms of the player were scattered in the grass, in the rivers, in the air, in the ground. A woman gathered the atoms; she drank and ate and inhaled; and the woman assembled the player, in her body.组成玩家的原子散布在草中，河流中，在那空气中，也在那大地中。一个女性收集了那些原子；她饮用、进食、吸入；而后那女性在她的身体中，孕育了玩家。 And the player awoke, from the warm, dark world of its mother’s body, into the long dream.然后那玩家醒来了，从一个温暖，昏暗的母亲体内，进入了漫漫长梦。 And the player was a new story, never told before, written in letters of DNA. And the player was a new program, never run before, generated by a sourcecode a billion years old. And the player was a new human, never alive before, made from nothing but milk and love.而那玩家是一个新的故事，从未被讲述过，由DNA的语言书写着。而那玩家是一个新的程序，从未被运行过，由上亿年的源代码生成。而那玩家是一个新的人，从未生活过，由奶和爱组成。 You are the player. The story. The program. The human. Made from nothing but milk and love.你就是那玩家。那个故事。那个程序。那个人类。仅由奶和爱组成。 Let’s go further back.我们再往更远的过去回退一点。 The seven billion billion billion atoms of the player’s body were created, long before this game, in the heart of a star. So the player, too, is information from a star. And the player moves through a story, which is a forest of information planted by a man called Julian, on a flat, infinite world created by a man called Markus, that exists inside a small, private world created by the player, who inhabits a universe created by…那由七千亿亿亿原子组成的玩家的身体被创造了，远在这游戏之前，在一颗恒星的内部。所以那玩家也是，来自一颗恒星的信息。而这个玩家贯穿这个故事的始末，源于一个叫Julian的人种下的信息种子长成的森林，一个叫Markus的男人创造的无限世界，存在于一个由玩家创造的小的，私人世界里，而那又继承了宇宙创造的…… Shush. Sometimes the player created a small, private world that was soft and warm and simple. Sometimes hard, and cold, and complicated. Sometimes it built a model of the universe in its head; flecks of energy, moving through vast empty spaces. Sometimes it called those flecks “electrons” and “protons”.嘘。有时这个玩家创造的小天地是柔软，温暖和简单的。有时是坚硬，冰冷和复杂的。有时他在脑中建造出宇宙的模型；斑斑点点的能量穿越广阔空旷的空间。有时他称呼这些斑点为“电子”和“质子”。 Sometimes it called them “planets” and “stars”.有时他称呼他们为“行星”和“恒星”。 Sometimes it believed it was in a universe that was made of energy that was made of offs and ons; zeros and ones; lines of code. Sometimes it believed it was playing a game. Sometimes it believed it was reading words on a screen.有时他确信他存在于一个由“开”和“关”；“零”和“一”；一行行的命令组成的宇宙。有时他确信他是在玩一个游戏。有时他确信他是在读着屏幕上的文字。 You are the player, reading words…你就是那玩家，阅读着文字…… Shush… Sometimes the player read lines of code on a screen. Decoded them into words; decoded words into meaning; decoded meaning into feelings, emotions, theories, ideas, and the player started to breathe faster and deeper and realised it was alive, it was alive, those thousand deaths had not been real, the player was alive嘘……有时这玩家读屏幕上的命令行。将它们解码成为文字；将文字解码为意义；将意义解码为感情，情绪，理论，想法，而玩家的呼吸开始急促并意识到了他是活着的，他是活生生的，那上千次的死亡不是真的，玩家是活着的。 You. You. You are alive.你。你。你是活着的。 and sometimes the player believed the universe had spoken to it through the sunlight that came through the shuffling leaves of the summer trees而有时这玩家相信宇宙通过穿越夏日树叶的那斑斓的阳光对他说话。 and sometimes the player believed the universe had spoken to it through the light that fell from the crisp night sky of winter, where a fleck of light in the corner of the player’s eye might be a star a million times as massive as the sun, boiling its planets to plasma in order to be visible for a moment to the player, walking home at the far side of the universe, suddenly smelling food, almost at the familiar door, about to dream again有时这玩家相信宇宙透过晴朗的冬日夜空中，存在于他眼中一隅的星点星光，可能比太阳大上上百万倍的恒星沸腾着的电浆那一瞬间发出来的光对他说话，在宇宙的远侧行走回家的路上，突然闻到了食物，在那熟悉的门前，他又准备好再一次投入梦境 and sometimes the player believed the universe had spoken to it through the zeros and ones, through the electricity of the world, through the scrolling words on a screen at the end of a dream而有时玩家相信宇宙透过零和一，透过世界的电力，透过屏幕上滚动的文字和梦的终结对他说话 and the universe said I love you宇宙说我爱你 and the universe said you have played the game well宇宙说你很好地玩了这游戏 and the universe said everything you need is within you宇宙说一切你所需的你都具有 and the universe said you are stronger than you know宇宙说你比你所知的要强大 and the universe said you are the daylight宇宙说你就是日光 and the universe said you are the night宇宙说你就是黑夜 and the universe said the darkness you fight is within you宇宙说你所斗争的黑暗就在你心中 and the universe said the light you seek is within you宇宙说你所寻找的光明就在你心中 and the universe said you are not alone宇宙说你不是孤独的 and the universe said you are not separate from every other thing宇宙说你不是和所有的事物所隔绝的 and the universe said you are the universe tasting itself, talking to itself, reading its own code宇宙说你就是宇宙品尝着自己，对自己说话，阅读着他自己的代码。 and the universe said I love you because you are love.宇宙说我爱你因为你就是爱。 And the game was over and the player woke up from the dream. And the player began a new dream. And the player dreamed again, dreamed better. And the player was the universe. And the player was love.曲终人散，黄粱一梦。玩家开始了新的梦境。玩家再次做起了梦，更好的梦。玩家就是宇宙。玩家就是爱。 You are the player.你就是那个玩家。 Wake up.该醒了。 终末之诗全文中文翻译及本文其他部分内容来自Minecraft Wiki，使用CC BY-NC-SA 3.0协议。","link":"/2020/11/23/Minecraft-EndPoem/"},{"title":"魔塔问题属于NPC的证明","text":"通过证明：0-1背包问题可归约到标准魔塔问题，得出判定问题——标准魔塔问题是NPC的 标准魔塔问题的定义通俗的讲，标准魔塔问题是魔塔的简化，只考虑生命、攻击、防御、红蓝宝石，数值无上限；不考虑钥匙、金币、商店、道具等。 严格定义给定一张$w\\times h$的网格地图，地图上有墙与平地，同时给定玩家起点与终点坐标。给定玩家的初始属性：生命($HP$)、攻击($OFS$)、防御($DFS$)。地图的平地上一共有$n$个物件，它们可以是以下之一： 红宝石：玩家移动到该位置时可增加$X_i$点攻击，获得后该位置变为平地； 蓝宝石：玩家移动到该位置是可增加$Y_i$点防御，获得后该位置变为平地； 怪物：第$i$个怪物具有生命值$h_i$，攻击$o_i$，防御$d_i$. 与怪物战斗会损失$damage$点生命，只有生命值严格大于$damage$时才可击败通过，击败后该位置变为平地，$damage$的计算方法见后文。 所有的数值均为非负整数，且没有上限。 问：玩家可以成功走到终点吗？ damage计算方法设玩家此时的生命，攻击，防御分别为$h_p$,$o_p$,$d_p$；对应怪物的生命，攻击，防御分别为$h_i$,$o_i$,$d_i$，则$damage=f(o_p,d_p,h_i,o_i,d_i)$.$$f(o_p,d_p,h_i,o_i,d_i) = \\begin{cases}+\\infty&amp;, o_p\\leq d_i \\\\0&amp; ,o_p&gt;d_i \\mbox{且} o_i\\leq d_p \\\\\\lfloor\\frac{h_p-1}{o_p-d_i}\\rfloor\\times(o_i-d_p)&amp; ,Otherwise\\end{cases}$$上面公式的解释：通俗来讲玩家每回合攻击怪物$o_p-d_i$点生命，怪物每回合攻击玩家$o_i-d_p$点生命。玩家先行动，如此循环直到某一方生命减为0或更低。 任何魔塔问题都是NP证据$t$即为攻略，攻略至多$O(n)$个步骤，只需逐步模拟即可验证魔塔是否可通关。 标准魔塔问题不比0-1背包问题简单归约对于一个0-1背包问题的实例：重量${w_1,\\cdots,w_n}$，价值${v_1,\\cdots,v_n}$. 容量$L$，问其价值可以达到$V$吗？ 设$S_v=\\sum v_i$，用如下方法构造标准魔塔问题： 初始状态：玩家生命为$L+1$，攻击$S_v$，防御$0$. 地图有一个主路，可以直接达到终点，但被一个生命$1$，攻击$1$，防御$S_v+V-1$的怪物$M_0$守住门口。 有$n$个支路，第$i$条支路有一个可增加$v_i$点攻击的红宝石，但被一个生命$2S_V$，攻击$w_i$，防御$0$的怪物$M_i$守住路口。 这是一个多项式时间变换，如果这个标准魔塔问题有解，则0-1背包输出“Yes”，否则输出”No”. 正确性证明有以下明显的事实： 当且仅当玩家通过吃宝石增加共计$V$点攻击后，才可击败$M_0$，且玩家不会受到伤害； 玩家在地图中的攻击不小于$S_v$，且若有支路怪存活，攻击严格小于$2S_v$。这意味着，只要有支路怪存活，支路怪均恰好攻击玩家一次，即对玩家造成$w_i$点伤害。 因此，没击败一个支路怪$M_i$获得对应宝石，即等价于将第$i$件物品放入背包；背包容量为$L$，等效于玩家生命始终为正。一旦获得到了$V$点攻击（即价值达到$V$），则可无损伤地击败$M_0$通关。 由此证明了：0-1背包问题$\\leq_p$标准魔塔问题。 有商店的魔塔问题事实上，红宝石增加能力值永远为常数的情形，上述方法会失效；以常数1为例，即便可以通过$v_i$个宝石以等效实现增加$v_i$点能力，但这已经不是多项式时间变换。注：如果魔塔中有增加$1,2,4,\\cdots$点数值的不同宝石，则$\\log v_i$个宝石即可等效，依然是多项式时间变换。 但注意到，几乎所有的魔塔都拥有金币-商店系统，下面指出：有商店的魔塔问题不比0-1背包问题简单。 事实上此结论trivial，仿照标准魔塔问题的归约方案，去掉所有的宝石，改为击败怪物$M_i$可获得$v_i$点金币；还有一个商店，$V$点金币可以增加$V$点攻击，这依然是多项式时间变换。 有机关门的魔塔问题一旦引入机关门，便容易证明3-SAT$\\leq_p$有机关门的魔塔问题，细节从略。 结论由于0-1背包问题和3-SAT问题都是已知的NPC，因此： 标准魔塔问题是NPC 有商店的魔塔问题是NPC 有机关门的魔塔问题是NPC 事实上，以上三种问题往往是某个实际魔塔问题的特殊情况（子问题），如果算法A能够求解出某个实际魔塔的通关路线，则算法A也能解决以上三个问题之一（通常是有商店的魔塔问题），由此可以得到推论： 目前，人类没有找到可以求解实际魔塔问题通关路线的多项式时间算法，且目前普遍认为不存在多项式时间算法。对于一个魔塔求解器而言，利用回溯与分支限界的算法应该是高性价比的算法之一。","link":"/2020/11/17/MagicTower-in-NPC/"},{"title":"About me","text":"Education / 教育背景 Undergraduate Student, major in Artificial Intelligence Science &amp; Technology, (智能科学与技术系)School of Electronics Engineering and Computer Science, (信息科学技术学院)Peking University (北京大学) 北京大学信息科学技术学院智能科学与技术系2019级本科生，2020-2021学年秋季学期计算机系统导论课程助教。 教育经历2012.09 - 2018.06 西南大学附属中学2018.09 - 2019.09 北京大学 物理学院 (2018级本科生)2019.09 - today 北京大学 信息科学技术学院(2019级本科生) Honors/荣誉 2019-2020 国家奖学金/National Scholarship 2019-2020 北京大学三好学生/Merit Student of Peking University 2020-2021 国家奖学金/National Scholarship 2020-2021 北京大学三好学生标兵/Pacemaker to Merit Student of Peking University Interest / 业内兴趣 机器学习、深度学习、数据科学 计算机视觉、图像处理 游戏编程与开发 计算机网络 …… Hobby / 业余爱好 Minecraft （原版生电方向） 电脑游戏 （World of Goo, Geometry Dash, 魔塔……） 三国杀 天文、物理 围棋（初学ing） …… Skills / 一些会的东西 一点C++, C, Python3, JAVA, Ruby…… 一点Photoshop, Audition 一点Markdown, latex 一些Minecraft红石 羽毛球、乒乓球、棋牌…… Movies&amp;Animes/喜欢的电影&amp;动漫 《千与千寻》 《命运石之门》系列 《加勒比海盗》系列 《你的名字。》 …… Friends / 友链To be Update… Contacts / 联系方式 spirited_away@pku.edu.cn","link":"/2020/11/17/About-me/"}],"tags":[{"name":"学期总结","slug":"学期总结","link":"/tags/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"},{"name":"AstroMC","slug":"AstroMC","link":"/tags/AstroMC/"},{"name":"数理基础","slug":"数理基础","link":"/tags/%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"魔塔","slug":"魔塔","link":"/tags/%E9%AD%94%E5%A1%94/"},{"name":"NPC","slug":"NPC","link":"/tags/NPC/"},{"name":"TCS","slug":"TCS","link":"/tags/TCS/"},{"name":"思绪","slug":"思绪","link":"/tags/%E6%80%9D%E7%BB%AA/"},{"name":"代码","slug":"代码","link":"/tags/%E4%BB%A3%E7%A0%81/"}],"categories":[{"name":"Ideas","slug":"Ideas","link":"/categories/Ideas/"},{"name":"Minecraft","slug":"Minecraft","link":"/categories/Minecraft/"}]}